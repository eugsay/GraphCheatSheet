# [Поиск в глубину](http://e-maxx.ru/algo/dfs)
Это один из основных алгоритмов на графах.
В результате поиска в глубину находится лексикографически первый путь в графе.
Алгоритм работает за O (N+M).
## Описание алгоритма
Пусть задан граф G=(V,E), где  V — множество вершин графа, {\displaystyle E} E — множество ребер графа. Предположим, что в начальный момент времени все вершины графа окрашены в белый цвет. Выполним следующие действия:

Пройдём по всем вершинам v\in V.
Если вершина v белая, выполним для неё DFS(v).
Процедура DFS (параметр — вершина u\in V)

Перекрашиваем вершину u в серый цвет.
Для всякой вершины w, смежной с вершиной u и окрашенной в белый цвет, рекурсивно выполняем процедуру DFS(w).
Перекрашиваем вершину u в чёрный цвет.
Часто используют двухцветные метки — без серого, на 1-м шаге красят сразу в чёрный цвет.

## Реализация

<pre><code class="c++ language-c++">vector &lt; vector&lt;int&gt; &gt; g; // граф
int n; // число вершин

vector&lt;int&gt; color; // цвет вершины (0, 1, или 2)

vector&lt;int&gt; time_in, time_out; // "времена" захода и выхода из вершины
int dfs_timer = 0; // "таймер" для определения времён

void dfs (int v) {
    time_in[v] = dfs_timer++;
    color[v] = 1;
    for (vector&lt;int&gt;::iterator i=g[v].begin(); i!=g[v].end(); ++i)
        if (color[*i] == 0)
            dfs (*i);
    color[v] = 2;
    time_out[v] = dfs_timer++;
}
</code></pre>

Это наиболее общий код. Во многих случаях времена захода и выхода из вершины не важны, так же как и не важны цвета вершин (но тогда надо будет ввести аналогичный по смыслу булевский массив used). Вот наиболее простая реализация:

<pre><code class="c++ language-c++">vector &lt; vector&lt;int&gt; &gt; g; // граф
int n; // число вершин

vector&lt;char&gt; used;

void dfs (int v) {
    used[v] = true;
    for (vector&lt;int&gt;::iterator i=g[v].begin(); i!=g[v].end(); ++i)
        if (!used[*i])
            dfs (*i);
}
</code></pre>

## Применения алгоритма
- Поиск любого пути в графе.
- Поиск лексикографически первого пути в графе.
- Проверка, является ли одна вершина дерева предком другой:
В начале и конце итерации поиска в глубину будет запоминать "время" захода и выхода в каждой вершине. Теперь за O(1) можно найти ответ: вершина i является предком вершины j тогда и только тогда, когда starti < startj и endi > endj.
- Задача LCA (наименьший общий предок).
- Топологическая сортировка:
Запускаем серию поисков в глубину, чтобы обойти все вершины графа. Отсортируем вершины по времени выхода по убыванию - это и будет ответом.
- Проверка графа на ацикличность и нахождение цикла
- Поиск компонент сильной связности: Сначала делаем топологическую сортировку, потом транспонируем граф и проводим снова серию поисков в глубину в порядке, определяемом топологической сортировкой. Каждое дерево поиска - сильносвязная компонента.
- Поиск мостов:
Сначала превращаем граф в ориентированный, делая серию поисков в глубину, и ориентируя каждое ребро так, как мы пытались по нему пройти. Затем находим сильносвязные компоненты. Мостами являются те рёбра, концы которых принадлежат разным сильносвязным компонентам.
